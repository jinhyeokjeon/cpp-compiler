# 6. 가상머신

유랭 컴파일러는 유랭 가상머신을 대상으로 목적 코드를 생성했으므로 생성한 목적 코드를 실행할 가상머신이 필요하다. 이번 장에서는 유랭의 가상머신을 구현해 목적 코드를 실행해 본다. 

목적 코드를 실행하는 방법은 단순하다. 코드 생성 단계의 결과물은 선형 구조인 코드 리스트이므로 리스트에 담긴 목적 코드를 순차적으로 하나씩 읽고 실행하기를 반복하면 된다.

## 6.1 호출 스택과 스택 프레임

인터프리터에서는 모든 문과 식의 실행이 함수 단위로 이루어졌다. 따라서 무언가를 따로 하지 않아도 함수의 실행은 호출한 순서대로 실행되고, 호출한 순서의 반대로 종료됐다.

함수가 호출되고 종료되는 과정이 마치 자료 구조 중 스택의 동작과 같아 이를 호출 스택이라 한다. 인터프리터는 C++의 호출 스택을 사용해 실행했다. 그런데 코드 생성 단계에서 만든 목적 코드에는 C++의 함수 같은 것은 없으므로 가상 머신은 함수가 호출된 순서대로 실행하고 호출된 순서의 역순으로 종료하도록 호출 스택을 제공해야 한다.

함수는 매개변수와 지역변수를 가진다. 그리고 함수 내에서는 식을 사용할 수 있으므로 식을 계산하기 위한 피연산자 스택이 필요하다. 또한 목적 코드 리스트에서 함수는 명령어들의 묶음이므로 명령어들을 순서대로 실행하기 위한 명령어 포인터가 필요하다.

정리하면 함수를 실행하기 위해서는 변수의 값을 저장할 공간, 식의 피연산자와 결과값을 저장할 공간, 다음에 실행할 명령어의 위치를 가리키는 포인터가 필요하다. 이렇게 함수를 실행하기 위해 필요한 공간을 스택 프레임이라고 한다. 다음은 스택 프레임을 표현한 구조체다.
```cpp
struct StackFrame {
  vector<any> variables;
  vector<any> operandStack;
  size_t instructionPointer = 0;
};
```

호출 스택은 단순히 스택 프레임의 리스트다. 다음과 같다. 호출 스택은 흔히 콜 스택이라고 부른다.
```cpp
static vector<StackFrame> callStack;
```

유랭 가상머신은 명령어 포인터를 스택 프레임, 즉 함수별로 관리한다. 그런데 main() 함수의 스택 프레임을 생성하기 전에는 명령어 포인터를 저장할 공간이 없다. 이를 해결하고자 가상머신은 일종의 스타트 업 함수의 스택 프레임을 생성한다. 코드 리스트의 첫 번째 코드부터 차례대로 실행해야 하므로 명령어 포인터는 0이다.

다음은 아래 코드에 대해 생성된 코드 리스트이다.
```cpp
func main() {
  print(factorial(3));
}

func factorial(var n) {
  if(n < 2) {
    return 1;
  }
  return n * factorial(n - 1);
}
```

```
startup()
- 변수 배열
- 피연산사 스택
- 명령어 포인터: 0
```

주소 0의 코드는 GetGlobal "main" 이고, main() 함수의 주소는 3이다. 피연산자 스택에 3을 넣는다. 그리고 주소 0의 코드를 실행했으므로 명령어 포인터는 1 증가한다.

```
startup()
- 변수 배열
- 피연산자 스택: 3
- 명령어 포인터: 1
```

주소 1의 코드는 Call [0] 이다. main() 함수의 스택 프레임을 생성해 콜 스택에 넣는다. 이때 main() 함수의 명령어 포인터 초기값은 startup() 함수의 피연산자 스택에서 가져온다.

```
startup()
- 변수 배열
- 피연산자 스택
- 명령어 포인터: 1
main()
- 변수 배열
- 피연산자 스택
- 명령어 포인터: 3
```

main() 함수의 목적 코드를 실행하다가 주소 5의 코드 GetGlobal "factorial"을 실행한 상태를 보자.

```
startup()
- 변수 배열
- 피연산자 스택
- 명령어 포인터: 1
main()
- 변수 배열
- 피연산자 스택: 3, 9
- 명령어 포인터: 5
```

주소 6의 코드는 Call [1] 이다. factorial() 함수의 스택 프레임을 생성해 콜 스택에 넣는다. 이때 main() 함수의 피연산자 스택에 있던 factorial() 함수의 주소 9는 factorial() 함수의 명령어 포인터 값이 된다.

```
startup()
- 변수 배열
- 피연산자 스택
- 명령어 포인터: 1
main()
- 변수 배열
- 피연산자 스택:
- 명령어 포인터: 6
factorial(3)
- 변수 배열: 3
- 피연산자 스택
- 명령어 포인터: 9
```

factorial() 함수의 목적 코드를 실행하다가 주소 21의 코드 GetGlobal "factorial"을 실행한 상태를 보자.

```
startup()
- 변수 배열
- 피연산자 스택
- 명령어 포인터: 1
main()
- 변수 배열
- 피연산자 스택:
- 명령어 포인터: 6
factorial(3)
- 변수 배열: 3
- 피연산자 스택: 3, 2, 9
- 명령어 포인터: 21
```

이 때 factorial() 함수의 피연산자 스택에는 식 n * factorial(n - 1) 의 피연산자 값들이 쌓여있다. 3은 매개변수 n의 값이고, 2는 n - 1 의 결과값이고, 9는 factorial() 함수의 주소다.

주소 22의 코드는 Call[1] 이다. factorial() 함수의 스택 프레임을 생성해 콜 스택에 넣는다. factorial() 함수를 처음 호출했을 때와 마찬가지로 피연산자 스택에 쌓여 있는 값 9는 새로 호출하는 factorial() 함수의 명령어 포인터가 되고, 값 2는 새로 호출하는 factorial() 함수의 매개변수 n의 값이 된다.
```
startup()
- 변수 배열
- 피연산자 스택
- 명령어 포인터: 1
main()
- 변수 배열
- 피연산자 스택: 
- 명령어 포인터: 6
factorial(3)
- 변수 배열: 3
- 피연산자 스택: 3
- 명령어 포인터: 22
factorial(2)
- 변수 배열: 2
- 피연산자 스택
- 명령어 포인터: 9
```

계속해서 목적 코드를 실행하다가 factorial() 함수에서 매개변수 n의 값이 2보다 작을 때 1을 반환하는 시점을 살펴보자. 목적코드 주소 15에 해당한다.
```
startup()
- 변수 배열
- 피연산자 스택
- 명령어 포인터: 1
main()
- 변수 배열
- 피연산자 스택:
- 명령어 포인터: 6
factorial(3)
- 변수 배열: 3
- 피연산자 스택: 3
- 명령어 포인터: 22
factorial(2)
- 변수 배열: 2
- 피연산자 스택: 2
- 명령어 포인터: 22
factorial(1)
- 변수 배열: 1
- 피연산자 스택: 1
- 명령어 포인터: 15
```

주소 15의 Return 코드가 실행되면 factorial(1) 함수의 스택 프레임이 콜 스택에서 제거된다. 이때 피연산자 스택에 쌓여 있는 반환값 1은 factorial(2) 함수의 피연산자 스택에 들어가고, factorial(2) 함수의 명령어 포인터는 1 증가해 23이 된다.
```
startup()
- 변수 배열
- 피연산자 스택
- 명령어 포인터: 1
main()
- 변수 배열
- 피연산자 스택:
- 명령어 포인터: 6
factorial(3)
- 변수 배열: 3
- 피연산자 스택: 3
- 명령어 포인터: 22
factorial(2)
- 변수 배열: 2
- 피연산자 스택: 2, 1
- 명령어 포인터: 23
```

주소 23의 Multiply 코드는 피연산자 스택에서 값 두개를 꺼내 곱한 후 그 결과값을 다시 피연산자 스택에 넣으므로 factorial(2) 함수의 피연산자 스택에는 2와 1의 곱인 2가 남게 된다. 이어서 주소 24의 Return 코드가 실행되면 마찬가지로 factorial(2) 함수의 스택 프레임이 콜 스택에서 제거된다. 또한 이 과정에서 피연산자 스택에 쌓여 있는 2가 factorial(2) 함수의 반환값이 돼 factorial(3) 함수의 피연산자 스택에 들어가고 factorial(3) 함수의 명령어 포인터는 1 증가해 23이 된다.
```
startup()
- 변수 배열
- 피연산자 스택
- 명령어 포인터: 1
main()
- 변수 배열
- 피연산자 스택:
- 명령어 포인터: 6
factorial(3)
- 변수 배열: 3
- 피연산자 스택: 3, 2
- 명령어 포인터: 23
```

factorial(3) 함수는 명령어 23을 실행하며 피연산자 스택에서 두 값을 꺼내 곱한 결과값인 6을 다시 피연산자 스택에 넣는다. 주소 24의 코드를 실행하면 main() 함수의 피연산자 스택에는 6이 들어가고, 명령어 포인터는 1 증가해 7이 된다.
```
startup()
- 변수 배열
- 피연산자 스택
- 명령어 포인터: 1
main()
- 변수 배열
- 피연산자 스택: 6
- 명령어 포인터: 7
```

주소 7의 Print [1] 코드는 피연산자 스택에서 값 하나를 꺼내 콘솔에 출력하므로, 콘솔에 숫자 6이 출력되며 피연산자 스택은 비게 된다. 이어서 주소 8의 Return 코드가 실행되면 main() 함수의 스택 프레임이 콜 스택에서 제거되고 startup() 함수의 명령어 포인터가 2가 된다.
```
startup()
- 변수 배열
- 피연산자 스택
- 명령어 포인터: 2
```

주소 2의 코드는 Exit 이므로 가상머신은 startup() 함수의 스택 프레임을 콜 스택에서 제거한 후 프로그램의 실행을 종료한다.

## 6.2 코드 실행기